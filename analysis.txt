## 1) Concise architecture summary

**What it is:**  
A small C#/.NET library (`Ozone`) that wraps **Microsoft Playwright** into a “flow/step” DSL for UI automation. It provides a `Context` object (Playwright + browser + page + optional element/collection/frame + shared items) and a set of composable “steps” for locating elements and performing actions/assertions.

**Main modules:**
- **Context model**
  - `Context.cs`: immutable-ish record carrying Playwright objects (`IPlaywright`, `IBrowser`, `IPage`, optional `IFrame`, `ILocator`, collection) and an `Items` dictionary for cross-step data passing.
- **Step composition**
  - `AsyncStep.cs`: chains `Func<Context, Task<Context>>` steps into a linked list with logging/tracing. Provides `|` operator overloads for chaining.
  - `FlowStep.cs`: defines a *synchronous* delegate `Context FlowStep(Context context)` (despite the comment saying asynchronous).
- **Step library / DSL**
  - `Flow.cs`: context creation and navigation (browser launch, new page, goto).
  - `Flow.Absolute.cs`: global element search helpers (CSS/XPath/Text) + conditional execution (`IfExists`) + “exists” probes.
  - `Flow.Relative.cs`: element search relative to the current `Context.Element`.
  - `Flow.Steps.cs`: async versions of actions (click, set text, assertions, loops, retry, etc.).
  - `Flow.Step.cs`: sync versions of many of the same actions (uses `.Wait()` / `.Result` heavily).
  - `Flow.Logging.cs`: basic console logging.
- **Misc**
  - `BrowserBrand.cs`: enum of supported browser brands.
  - `ExtensionMethods.cs`: Playwright locator helpers (`Text()`, `TextContains()`, etc.).
  - `OzoneException.cs`: custom exception.

**Entrypoints / typical usage:**
- `Flow.CreateContext(BrowserBrand, Uri, headless)` creates Playwright, launches browser, opens page, navigates, returns `Context`.
- Users then compose steps:
  - Async style: `await new AsyncStep(Flow.Find("#x")).Link(Flow.Click)...Bind(context)` or use `|` operators.
  - Sync style: `context | Flow.Find("#x") | Flow.Click` patterns inside `Flow.Step.cs` (but note there are two different paradigms coexisting).

---

## 2) Top 10 risks/issues (with file references)

1) **Resource leaks: Playwright/Browser/Page never disposed/closed**
   - `Flow.cs` creates `IPlaywright` and `IBrowser` but there’s no `DisposeAsync()`/`CloseAsync()` path, and `Context` doesn’t implement disposal.
   - Impact: zombie browser processes, file handles, CI instability.
   - Files: `Flow.cs`, `Context.cs`

2) **TLS security is explicitly weakened (`IgnoreHTTPSErrors = true`)**
   - `NewPageAsync(new() { IgnoreHTTPSErrors = true })`
   - Impact: tests can silently accept MITM / invalid certs; encourages insecure defaults.
   - Files: `Flow.cs`

3) **Deadlock/hang risk due to blocking on async (`.Wait()`, `.Result`)**
   - Extensive synchronous wrappers block on async Playwright calls.
   - Impact: deadlocks in environments with synchronization contexts; threadpool starvation; flaky hangs.
   - Files: `Flow.Step.cs` (many), also `Flow.Steps.cs` has at least one `.Result` (`SelectComboText`).

4) **Code duplication and API confusion: parallel sync and async “Flow” implementations**
   - `Flow.Step.cs` (sync) and `Flow.Steps.cs` (async) implement many similarly-named methods (`Click`, `SetText`, `Retry`, `Script`, `SwitchToFrame`, etc.).
   - Impact: easy to call the wrong one, inconsistent behavior/timeouts, hard to maintain.
   - Files: `Flow.Step.cs`, `Flow.Steps.cs`, `FlowStep.cs`

5) **`SwitchToFrame` does not actually switch frames (likely incorrect)**
   - Both sync/async `SwitchToFrame` use `FrameLocator(...).Locator(":root")` and then store it as `Element`, but `Context.Frame` is never set, so later “global” searches still run on the page (or main frame) rather than inside the iframe.
   - Impact: flows that expect frame scoping will be wrong/flaky.
   - Files: `Flow.Step.cs`, `Flow.Steps.cs`, `Context.cs` (EffectiveFrame exists but is unused by find methods except RootLocatorForSelector/RootLocatorForXPath which relies on `Frame`)

6) **`Context.EmptyContext()` discards shared Items**
   - Creates `new(..., items: new())` instead of carrying existing `Items`.
   - Impact: data passed between steps disappears unexpectedly.
   - Files: `Context.cs`

7) **Potential runtime exception: `AsyncStep.MethodTrace()` returns null but signature is non-nullable**
   - `public string MethodTrace()` returns `null` when `_step == null`.
   - With nullable enabled, this is inconsistent and could cause downstream NREs/logging issues.
   - Files: `AsyncStep.cs`

8) **Reflection-based logging can leak sensitive data and be expensive**
   - `AsyncStep.FormatTarget` introspects fields/properties and prints values (including strings).
   - Impact: secrets in captured closures (passwords, tokens) may be printed to console logs; performance overhead; potential exceptions.
   - Files: `AsyncStep.cs`, `Flow.Logging.cs`

9) **`Context.CreateProblem` both logs and throws; many callers “return context.CreateProblem(...)”**
   - The method always throws `OzoneException`, so the `return` is dead/unreachable logically.
   - Impact: confusing control flow; “HasProblem” patterns in sync Flow imply non-throwing error states, but here it always throws (also `HasProblem`/`WithoutFrame` appear referenced but not present in snapshot, suggesting mismatched design).
   - Files: `Context.cs`, `Flow.Step.cs` (references `HasProblem`), `Flow.Steps.cs`

10) **Timeout handling inconsistency / missing waits**
   - Some finds wait (`WaitForAsync(FindTimeout)`), others don’t (`FindByText` returns locator without waiting; `FindAllOnXPath` doesn’t wait).
   - Some click uses 60s timeout, other methods use defaults.
   - Impact: flakiness and non-deterministic behavior across steps.
   - Files: `Flow.Absolute.cs`, `Flow.Steps.cs`

---

## 3) Prioritized plan of next actions (smallest safe steps first)

1) **Make error handling coherent (decide: exceptions vs “problem state”)**
   - Either:
     - (A) keep exceptions: remove/stop using `HasProblem` patterns and ensure all steps are async-safe and exception-driven, or
     - (B) implement a non-throwing problem state in `Context` (e.g., `Problem` property) and make `CreateProblem` return a flagged context instead of throwing.
   - Small first step: update call sites to not rely on nonexistent `HasProblem` (or add it if intended).

2) **Stop blocking on async in library code**
   - Deprecate/remove `Flow.Step.cs` (sync) or rewrite it as truly synchronous by design (not recommended with Playwright).
   - Immediate minimal step: replace the worst `.Wait()`/`.Result` occurrences in commonly used paths (Click/Fill/Goto/WaitForLoadState) with `await` and expose only async API.

3) **Add proper disposal lifecycle**
   - Introduce something like `OzoneSession : IAsyncDisposable` that owns `IPlaywright`, `IBrowser`, `IPage` and can create a `Context`.
   - Minimal step: add `Flow.Close(Context)` that calls `Page.CloseAsync()`, `Browser.CloseAsync()`, `Playwright.Dispose()`/`DisposeAsync()`.

4) **Fix iframe support properly**
   - Change `SwitchToFrame` to actually resolve and store an `IFrame` into `Context.Frame` (not just a locator), and update `Context.RootLocatorForSelector/RootLocatorForXPath` to use `Frame` consistently (already does).
   - Add `WithoutFrame()` / `WithFrame(IFrame)` helpers on `Context` if missing.

5) **Secure defaults**
   - Change `IgnoreHTTPSErrors` default to `false`, or make it an explicit parameter on `CreateContext`.
   - Add clear docs warning when it’s enabled.

6) **Stop leaking sensitive data via tracing**
   - Make `AsyncStep.MethodTrace/FormatTarget` opt-in and/or redact likely-secret fields (password/token/key) and truncate long strings.
   - Provide a `Flow.LogLevel` and disable reflection logging by default.

7) **Fix `Context.EmptyContext()` to preserve Items**
   - Use the existing `Items` dictionary rather than `new()`, unless you explicitly want to clear it (then name it `ClearItems()`).
   - Add a unit test for “items survive across steps”.

8) **Normalize waits/timeouts**
   - Ensure all “Find” variants wait consistently (including `FindByText`, XPath collection find).
   - Centralize timeout configuration and allow overriding per call.

9) **Remove unused / misleading code**
   - `AsyncStep.ExtractMethodName` is unused.
   - `Flow.Steps.cs` has unused usings (`System.Collections.ObjectModel`, `System.Reflection.Emit`).
   - Tighten nullability annotations (e.g., `MethodTrace(): string?`).

10) **Add a small test suite**
   - Even 3–5 Playwright tests validating: find/click/settext, iframe switching, Items propagation, retry behavior.

---

## 4) Secrets / unsafe data callouts

- No hard-coded API keys/passwords were visible in the provided snapshot.
- **However, logging is potentially unsafe:**
  - `AsyncStep.FormatTarget` can print values from closure-captured fields/properties, including strings, which may contain credentials or tokens passed into steps.
  - `Flow.Log` prints everything to console unredacted.
  - Files: `AsyncStep.cs`, `Flow.Logging.cs`

If you want, I can propose a concrete redesign that unifies the library around a single async pipeline (`Func<Context, Task<Context>>`) and a disposable session wrapper, with minimal breaking changes.